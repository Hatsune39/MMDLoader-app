<!DOCTYPE html>
<html lang="en">
	<head>
		<title>THREE.MMDLoader sample - face tracking</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #fff;
				color: #000;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #000;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: right;
				right: 20px;
				z-index: 100;
				display: block;
			}
			#info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
			#container {
				position : relative;
			}
			#canvas {
				position : absolute;
				left : 0;
				top : 0;
			}
		</style>
	</head>

	<body>
		<div id="info">
		<a href="https://github.com/takahirox/three.js" target="_blank">MMDLoader</a><br />
		face tracking app<br />
		<br />
		Copyright<br />
		<a href="http://threejs.org" target="_blank">three.js</a><br />
		<a href="http://www.geocities.jp/higuchuu4/index_e.htm" target="_blank">Model Data</a><br />
		<a href="https://github.com/auduno/clmtrackr" target="_blank">Face tracking lib</a><br />
		<a href="http://auduno.github.io/clmtrackr/example.html" target="_blank">Video</a><br />
		</div>

		<div id="container">
			<video id="video" width="368" height="288" autoplay loop>
				<source src="./video/franck.ogv" type="video/ogg"/>
			</video>
			<canvas id="canvas" width="368" height="288"></canvas>
		</div>

		<script src="./libs/clmtrackr.min.js"></script>
		<script src="./libs/model_pca_20_svm.js"></script>

		<script src="three.js/three.min.js"></script>

		<script src="libs/charsetencoder.min.js"></script>
		<script src="libs/ammo.js"></script>
		<script src="three.js/TGALoader.js"></script>
		<script src="three.js/MMDLoader.js"></script>
		<script src="three.js/CCDIKSolver.js"></script>
		<script src="three.js/MMDPhysics.js"></script>

		<script src="three.js/Detector.js"></script>
		<script src="libs/stats.min.js"></script>

		<script>

			var videoInput = document.getElementById( 'video' );
			var ctracker = new clm.tracker();
			ctracker.init( pModel );
			ctracker.start( videoInput );

			var canvasInput = document.getElementById( 'canvas' );
			var cc = canvasInput.getContext( '2d' );

			var container, stats;

			var camera, scene, renderer;
			var helper, loader;

			var ready = false;
			var debug = false;

			var width = canvasInput.width;
			var height = canvasInput.height;

			var clock = new THREE.Clock();

			var boneDictionary = {};
			var modelDictionary = {};
			var morphDictionary = null;

			var modelParams = [
				{
					name: 'miku',
					file: 'model/miku/miku_v2.pmd',
					position: new THREE.Vector3( 0, -18.5,  0 )
				}
			];

			var poseParams = [
				{
					name: 'basic',
					file: 'vpd/imas/makoto_basic.vpd'
				}
			];

			var poses = {};

			var blinkMorphName = 'まばたき';
			var headBoneName = '頭';

			var blinkVmd = {
				metadata: {
					name: 'blink',
					coordinateSystem: 'right',
					morphCount: 11,
					cameraCount: 0,
					motionCount: 0
				},
				morphs: [
					{ frameNum:   0, morphName: blinkMorphName, weight: 0.0 },
					{ frameNum:  10, morphName: blinkMorphName, weight: 0.0 },
					{ frameNum:  15, morphName: blinkMorphName, weight: 1.0 },
					{ frameNum:  20, morphName: blinkMorphName, weight: 0.0 },
					{ frameNum:  40, morphName: blinkMorphName, weight: 0.0 },
					{ frameNum:  43, morphName: blinkMorphName, weight: 1.0 },
					{ frameNum:  46, morphName: blinkMorphName, weight: 0.0 },
					{ frameNum:  49, morphName: blinkMorphName, weight: 0.0 },
					{ frameNum:  52, morphName: blinkMorphName, weight: 1.0 },
					{ frameNum:  55, morphName: blinkMorphName, weight: 0.0 },
					{ frameNum: 200, morphName: blinkMorphName, weight: 0.0 },
				],
				cameras: [],
				motions: []
			};

			var onProgress = function ( xhr ) {
				if ( xhr.lengthComputable ) {
					var percentComplete = xhr.loaded / xhr.total * 100;
					console.log( Math.round(percentComplete, 2) + '% downloaded' );
				}
			};

			var onError = function ( xhr ) {
			};

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 45, width / height, 1, 2000 );
				camera.position.z = 6;

				// scene

				scene = new THREE.Scene();

				var ambient = new THREE.AmbientLight( 0x666666 );
				scene.add( ambient );

				var directionalLight = new THREE.DirectionalLight( 0x887766 );
				directionalLight.position.set( -1, 1, 1 ).normalize();
				scene.add( directionalLight );

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				renderer.setClearColor( new THREE.Color( 0xffffff ) );
				container.appendChild( renderer.domElement );

				// model

				helper = new THREE.MMDHelper( renderer );

				loader = new THREE.MMDLoader();
				loader.setDefaultTexturePath( './default/' );

				loadModels( function () {

					var mesh = helper.meshes[ 0 ];

					loadPoses( mesh, function () {

						//helper.poseAsVpd( mesh, poses[ 'basic' ] );

						loader.pourVmdIntoModel( mesh, blinkVmd, 'blink' );

						helper.setAnimation( mesh );

						createDictionary( mesh );

						startBlink( mesh );

						ready = true;

					} );

				} );

			}

			function loadModels ( callback ) {

				function load ( index ) {

					if ( index >= modelParams.length ) {

						callback();
						return;

					}

					var param = modelParams[ index ];

					loader.loadModel( param.file, function ( object ) {

						var mesh = object;
						mesh.position.copy( param.position );

						helper.add( mesh );

						/*
						 * Note: You must set Physics
						 *       before you add mesh to scene or any other 3D object.
						 * Note: Physics calculation is pretty heavy.
						 *       It may not be acceptable for most mobile devices yet.
				 		 */
						if ( ! isMobileDevice() ) {

							helper.setPhysics( mesh );

						}

						scene.add( mesh );

						load( index + 1 );

					}, onProgress, onError );

				}

				load( 0 );

			}

			function loadPoses ( mesh, callback ) {

				function load ( index ) {

					if ( index >= poseParams.length ) {

						callback();
						return;

					}

					var param = poseParams[ index ];

					loader.loadVpd( param.file, function ( vpd ) {

						poses[ param.name ] = vpd;

						load( index + 1 );

					}, onProgress, onError );

				}

				load( 0 );

			}

			function createDictionary ( mesh ) {

				var bones = mesh.skeleton.bones;

				for ( var i = 0; i < bones.length; i++ ) {

					var b = bones[ i ];
					boneDictionary[ b.originalName ] = i;

				}

				morphDictionary = mesh.morphTargetDictionary;

			}

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				if ( ready ) {

					var mesh = helper.meshes[ 0 ];

					//cc.clearRect( 0, 0, canvasInput.width, canvasInput.height );
					//ctracker.draw( canvasInput );

					updateModel( mesh );

					var delta = clock.getDelta();
					helper.animate( delta );
					helper.render( scene, camera );

				} else {

					renderer.clear();
					renderer.render( scene, camera );

				}

			}

			// easy mobile device detection
			function isMobileDevice () {

				if ( navigator === undefined || navigator.userAgent === undefined ) {

					return true;

				}

				var s = navigator.userAgent;

				if (    s.match( /iPhone/i )
//				     || s.match( /iPad/i )
				     || s.match( /iPod/i )
				     || s.match( /webOS/i )
				     || s.match( /BlackBerry/i )
				     || ( s.match( /Windows/i ) && s.match( /Phone/i ) )
				     || ( s.match( /Android/i ) && s.match( /Mobile/i ) ) ) {

					return true;

				}

				return false;

			}

			function startBlink ( mesh ) {

				mesh.mixer.clipAction( 'blinkMorph' ).play();

			}

			function stopBlink ( mesh ) {

				mesh.mixer.clipAction( 'blinkMorph' ).stop();

			}

			function updateModel ( mesh ) {

				if ( ! ctracker.getCurrentPosition() ) {

					return;

				}

				updateEyeball( mesh );
				//updateEyebrow( mesh );
				updateMouth( mesh );
				updateFaceZAngle( mesh );
				updateFaceYAngle( mesh );
				updateFaceXAngle( mesh );

			}

			function updateEyeball ( mesh ) {

				updateLeftEyeball( mesh );
				updateRightEyeball( mesh );

			}

			function updateLeftEyeball ( mesh ) {

				var rPosX = getLeftEyeballXPosition();
				var rPosY = getLeftEyeballYPosition();
				var bone = mesh.skeleton.bones[ boneDictionary[ '左目' ] ];
				var gbone = mesh.geometry.bones[ boneDictionary[ '左目' ] ];

				rPosX =  rPosX / 30;
				rPosY =  rPosY / 20;

				bone.position.x = gbone.pos[ 0 ] + rPosX;
				bone.position.y = gbone.pos[ 1 ] + rPosY;

			}

			function updateRightEyeball ( mesh ) {

				var rPosX = getRightEyeballXPosition();
				var rPosY = getRightEyeballYPosition();
				var bone = mesh.skeleton.bones[ boneDictionary[ '右目' ] ];
				var gbone = mesh.geometry.bones[ boneDictionary[ '右目' ] ];

				rPosX =  rPosX / 30;
				rPosY =  rPosY / 20;

				bone.position.x = gbone.pos[ 0 ] + rPosX;
				bone.position.y = gbone.pos[ 1 ] + rPosY;

			}

			function updateEyebrow ( mesh ) {

				var pos = getEyebrowPosition();

				pos = pos - 10;
				pos = pos / 10;

				pos = Math.min( 1.0, pos );
				pos = Math.max( 0.0, pos );

				mesh.morphTargetInfluences[ morphDictionary[ '下' ] ] = pos;

			}

			function updateMouth ( mesh ) {

				var sizeX = getMouthXSize();
				var sizeY = getMouthYSize();

				sizeX = Math.max( 0.0, sizeX - 48.0 );
				sizeX = Math.min( 0.1, sizeX / 10 );

				sizeY = Math.max( 0.0, sizeY - 2.0 );
				sizeY = Math.min( 0.6, sizeY / 10 );

				mesh.morphTargetInfluences[ morphDictionary[ 'い' ] ] = sizeX;
				mesh.morphTargetInfluences[ morphDictionary[ 'あ' ] ] = sizeY;

			}

			function updateFaceXAngle ( mesh ) {

				var angle = getFaceXAngle();
				var bone = mesh.skeleton.bones[ boneDictionary[ '頭' ] ];

				angle = angle - 35;

				bone.rotation.x = angle / 50;

			}

			function updateFaceYAngle ( mesh ) {

				var angle = getFaceYAngle();
				var bone = mesh.skeleton.bones[ boneDictionary[ '頭' ] ];

				bone.rotation.y = angle / 10;

			}

			function updateFaceZAngle ( mesh ) {

				var angle = getFaceZAngle();
				var bone = mesh.skeleton.bones[ boneDictionary[ '頭' ] ];

				bone.rotation.z = -angle;

			}

			function calculateDistance ( p1, p2 ) {

				var dx = p1[ 0 ] - p2[ 0 ];
				var dy = p1[ 1 ] - p2[ 1 ];
				return Math.sqrt( dx * dx + dy * dy );

			}

			function getMouthXSize () {

				var p = ctracker.getCurrentPosition();

				var p1 = p[ 44 ];
				var p2 = p[ 50 ];

				return calculateDistance( p1, p2 );

			}

			function getMouthYSize () {

				var p = ctracker.getCurrentPosition();

				var p1 = p[ 60 ];
				var p2 = p[ 57 ];

				return calculateDistance( p1, p2 );

			}

			function getEyebrowPosition () {

				var p = ctracker.getCurrentPosition();

				var p1 = p[ 20 ];
				var p2 = p[ 63 ];

				return calculateDistance( p1, p2 );

			}

			function getFaceXAngle () {

				var p = ctracker.getCurrentPosition();

				var p1 = p[ 33 ];
				var p2 = p[ 62 ];

				return calculateDistance( p1, p2 );

			}

			function getFaceYAngle () {

				var p = ctracker.getCurrentPosition();

				var p1_1 = p[ 0 ];
				var p1_2 = p[ 23 ];

				var p2_1 = p[ 28 ];
				var p2_2 = p[ 14 ];

				var d1 = calculateDistance( p1_1, p1_2 );
				var d2 = calculateDistance( p2_1, p2_2 );

				return d1 / d2;

			}

			function getFaceZAngle () {

				var p = ctracker.getCurrentPosition();

				var p1 = p[ 29 ];
				var p2 = p[ 24 ];

				var dx = p1[ 0 ] - p2[ 0 ];
				var dy = p1[ 1 ] - p2[ 1 ];

				return dy / dx;

			}

			function getLeftEyeballXPosition () {

				var p = ctracker.getCurrentPosition();

				var p1 = p[ 30 ];
				var p2 = p[ 32 ];
				var p3 = p[ 28 ];

				var d1 = calculateDistance( p1, p2 );
				var d2 = calculateDistance( p3, p2 );

				return d1 - d2;

			}

			function getLeftEyeballYPosition () {

				var p = ctracker.getCurrentPosition();

				var p1 = p[ 29 ];
				var p2 = p[ 32 ];
				var p3 = p[ 31 ];

				var d1 = calculateDistance( p1, p2 );
				var d2 = calculateDistance( p3, p2 );

				return d1 - d2;

			}

			function getRightEyeballXPosition () {

				var p = ctracker.getCurrentPosition();

				var p1 = p[ 23 ];
				var p2 = p[ 27 ];
				var p3 = p[ 25 ];

				var d1 = calculateDistance( p1, p2 );
				var d2 = calculateDistance( p3, p2 );

				return d1 - d2;

			}

			function getRightEyeballYPosition () {

				var p = ctracker.getCurrentPosition();

				var p1 = p[ 24 ];
				var p2 = p[ 27 ];
				var p3 = p[ 26 ];

				var d1 = calculateDistance( p1, p2 );
				var d2 = calculateDistance( p3, p2 );

				return d1 - d2;

			}
		</script>

	</body>
</html>
